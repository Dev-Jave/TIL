### 알고리즘 성능 분석 방법
* 공간 복잡도(Space Complexity) : 알고리즘을 프로그램으로 실행하여 완료하기까지 필요한 총 저장 공간의 양
* 시간 복잡도(Time Complexity) : 알고리즘을 프로그램으로 실행하여 완료하기까지의 총 소요시간 = **컴파일 시간 + 실행 시간**

### 알고리즘 성능 분석 표기법
1) 빅-오 표기법(Big-Oh Notatio)


### 재귀호출
#### 1. 재귀호출의 개념
#### 3. 재귀호출 예2 : 하노이 탑
팩토리얼 함수는 단순 반복 구조이기 때문에 재귀호출 방식을 사용하지 않고 반복문으로 구현할 수 있지만 복잡한 재귀 구조 문제는 그렇지 않다. 대표적인 예가 **하노이 탑**(Tower of Hanoi)이다. 

![](/image/data_01.png)

```cpp
#include <stdio.h>

void hanoi(int n, int start, int work, int target);

int main() {
    hanoi(3, 'A', 'B', 'C');
    getchar();
    return 0;
}

void hanoi(int n, int start, int work, int target) {
    if(n == 1)
        printf("%c에서 원반 %d를(을) %c로 옮김 \n", start, n, target);
    else {
        hanoi(n -1, start, target, work);
        printf("%c에서 원반 %d를(을) %c로 옮김 \n", start, n, target);
        hanoi(n -1, work, start, target);
    }
}
```
# Ch.03 순차 자료구조와 선형 리스트
## 01) 순차 자료구조와 선형 리스트의 이해
### 1. 순차 자료구조의 개념
| 구분 | 순차 자료구조 | 연결 자료구조 |
| --- | --- | --- | 
| 메모리 저장 방식 | 메모리 저장 시작 위치부터 순서대로 연속 저장 | 물리적 위치 순서 상관없이 링크에 의해 논리적 순서를 표현 | 
| 연산 특징 | 삽입,삭제 연산을 해도 빈자리 없이 순서대로 연속 저장 | 삽입, 삭제 연산을 하여 논리적 순서가 변경돼도 링크 정보만 변경 | 
| 프로그램 기법 | 배열을 이용한 구현 | 포인터를 이용한 구현 | 

### 2. 선형 리스트의 표현
     
### 3. 선형 리스트의 배열 표현
#### **1차원 배열을 이용한 선형 리스트의 표현**
1차원 배열은 인덱스를 하나만 사용한다. 

#### **2차원 배열을 이용한 선형 리스트의 표현**
2차원 배열 구조를 논리적으로 표현할 때는 행과 열의 구조로 나타내지만, 실제로 메모리에는 1차원 구조로 저장된다. 2차원 
## 02) 선형 리스트의 연산과 알고리즘

## 03) 선형 리스트의 응용 및 구현
> 행렬(Matrix)은 행과 열로 구성된 자료구조이며, 행 개수가 m개, 열 개수가 n개이면 m x n 행렬이라 하고, 이 행렬을 구성하는 원소 개수는 (m x n)개가 된다.
* 정방행렬(Square Matrix) : 행렬 중에서 m과 n이 같은 행렬
* 전치행렬(Transposed Matrix) : 행렬의 행과 열을 서로 바꾸어 구성한 행렬


# Chapter 04. 연결 자료구조와 연결 리스트

## 01) 연결 자료구조와 연결 리스트의 이해
선형
## 02) 단순 연결 리스트

```c
insertMiddleNode(L, pre, x)
    new 

```
## 03) 원형 연결 리스트
### 1. 원형 연결 리스트의 개념
단순 연결 리스트에서 마지막 노드가 리스트의 첫 번째 노드를 가리키게 하여 리스트 구조를 원형으로 만든 연결 리스트를 원형 리스트(Circular Linked List)라고 한다.
```cpp
insertFirstNode(CL, x)
    new <- getNode();
    new.data <- x;
    if(CL == NULL)
```

## 04) 이중 연결 리스트


## 05) 연결 리스트의 응용 및 구현

스택은 접시와 책을 쌓아올리듯 일상에서 흔히 사용하는 쌓아올리는 방식을 추상화하여 자료구조로 정의한것이다.


!!대충 정리 -> 나중에 다시 정리할 것
큐는 두가지 포인트 front, rear 
스택은 top이라는 포인터가있는데 맨 위에 있는 것을 가르켜줬음.

큐의 연산
삽입 : enQueue, 삭제 : deQueue
입구랑 출구가 따로 있다! 

큐에 원소가 삽입되면 rear가 증가함. 삭제는 프론트에서 일어남. 삭제를 하면 front가 증가함.

순차 큐 : 1차원 배열을 이용한 큐  
공백상태는 front = rear

스택은 스택이 꽉 찬 것을 capacity보다 큰지 확인,  
큐는 rear값을 통해 ..

원형  큐는 나머지 연산자 mod를 사용  
3/ 4 = 0...3 (몫=0, 나머지=3)

포화상태는 ? 

힙에 생성되는 객체들은 new를 통해 할당되어 메모리 공간만 있고 이름이 없다. 그래서 포인터로 주소를 받아 사용한다 .. 

데크는 양쪽이 다 입구

운영체제 작업 큐
* 프린터 버퍼 큐
* 스케줄링 큐

# Chapter 07.트리
트리는 비선형 자료구조, 계층형 자료구조, 상위 원소에서 하위원소로 확장..  
ex. 윈도우 탐색기 탐색 과정    
포리스트는 서브 트리의 집합 (마치 숲처럼..)  
## 이진 트리(Binary Tree)
> 트리의 모든 노드의 차수를 2 이하로 제한하여 전체 트리의 차수가 2 이하가 되도록 정의  


## 이진 트리의 연결 구조 구현
이진 트리를 연결 자료구조로 표현하기 위해 사용하는 노드는 데이터를 저장하는 데이터 필드, 왼쪽 자식 노드를 연결하는 왼쪽 링크 필드, 오른쪽 자식 노드를 연결하는 오른쪽 링크 필드로 구성한다. 자식 노드가 없는 경우에는 링크 필드에 NULL을 저장하여 포인터로 설정한다.

## 이진 탐색 트리
### 이진 탐색 트리의 삽입 연산
#### 1) 먼저 탐색 연산 수행
#### 2) 탐색 실패한 위치에 원소 삽입
ㅠ
